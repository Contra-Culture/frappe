<DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>frappe.js</title>
    <script>
        const Obj = {};
        // returns universe
        function testTypes(ts) {
          let typeSpecs = [],
              error = null;
          if (!Array.isArray(ts)) {
            typeSpecs = null;
            error = "invalid types: array expected";
            return {typeSpecs, error}
          }
          for (let i = 0, t = ts[i]; i < ts.length; t = ts[i++]) {
            let {typeSpec, error} = testType(t);
            if (error !== null) {
              typeSpecs = null;
              error =  `invalid type (#defID ${i}): ${error}`;
              return {typeSpecs, error}
            }
            typeSpecs.push(typeSpec);
          }
          return {typeSpecs, error}
        }

        function testType(t) {
          let typeSpec = { props: [],
                           invariant: null,
                           reactions: [],
                           creator: null,
                           destroyer: null,
                         },
              error = null;
          if (typeof t !== "object") {
            typeSpec = null;
            error = "invalid type: object expected";
            return {typeScpec, error}
          }
          if (!Array.isArray(t.props)) {
            typeSpec = null;
            error = "invalid properties: array expected";
            return {typeSpec, error};
          }
          for (let i = 0,
                   p = t.props[i];
               i < t.props.length;
               p = t.props[i++]) {
            if (typeof p.name !== "string") {
              typeSpec = null;
              error = `invalid property name: string expected`;
              return
            }
            for (let ii = 0,
                     kp = typeSpec.props[ii];
                 ii < typeSpec.props.length;
                 kp = typeSpec.props[ii++]) {
              if (p.name === kp.name) {
                typeSpec = null;
                error = `invalid property: "${p.name}" already specified`;
                return {typeSpec, error}
              }
            }
            if (typeof p.guard !== "function") {
              typeSpec = null;
              error = "invalid property guard: function expected";
              return
            }
            typeSpec.props.push({
              name: p.name,
              guard: p.guard,
            });
          }
          if (typeof t.invariant !== "function") {
            typeSpec = null;
            error = "invalid invariant: function expected";
            return {typeSpec, error};
          }
          typeSpec.invariant = t.invariant;

          if (typeof t.creator !== "function") {
            typeSpec = null;
            error = "invalid creator: function expected";
            return {typeSpec, error};
          }
          typeSpec.creator = t.creator;

          if (typeof t.destroyer !== "function") {
            typeSpec = null;
            error = "invalid destroyer: function expected";
            return {typeSpec, error};
          }
          typeSpec.destroyer = t.destroyer;

          if (!Array.isArray(t.reactions)) {
            typeSpec = null;
            error = "invalid reactions: array expected";
            return {typeSpec, error};
          }
          for (let i = 0,
                   r = t.reactions[i];
               i < t.reactions.length;
               r = t.reactions[i++]) {
            if (typeof r !== "object") {
              typeSpec = null;
              error = "invalid reaction: object expected";
              return {typeSpec, error};
            }
            if (typeof r.event !== "string") {
              typeSpec = null;
              error = "invalid reaction event: string expected";
              return {typeSpec, error};
            }
            if (typeof r.reactor !== "object") {
              typeSpec = null;
              error = "invalid reaction reactor: object expected";
              return {typeSpec, error};
            }
            typeSpec.reactions.push(r)
          }
          return {typeSpec, error};
        }

        function testChannels(chs) {
          let channelsSpec = [],
              error = null;
          if (!Array.isArray(chs)) {
            channelsSpec = null;
            error = "invalid channels: array expected";
            return {channelsSpec, error};
          }
          for (let i = 0,
                   ch = chs[i];
               i < chs.lenght;
               ch = chs[i++]) {
            if (typeof ch !== "object") {
              channelsSpec = null;
              error = "invalid channel: object expected"
              return { channelsSpec, error }
            }
            if (typeof ch.name !== "string") {
              channelsSpec = null;
              error = "invalid channel name: string expected"
              return {channelsSpec, error}
            }
            if (typeof ch.guard !== "function") {
              channelsSpec = null;
              error = "invalid channel guard: function expected"
              return { channelsSpec, error }
            }
            channelsSpec.push({
              name: ch.name,
              guard: ch.guard,
            })
          }
          return {channelsSpec, error};
        }

        function testRuntime(r) {
          testHooks(r.hooks);
          testObjects(r.objects);
          testMessages(r.messages);
        }
        function testHooks(hs) {
          let hooksSpec = { onStart: null,
                            onError: null,
                            onFinish: null,
                          },
              error = null;
          if (typeof hs !== "object") {
            hooksSpec = null;
            error = "invalid hooks: expected object";
            return {hooksSpec, error};
          }
          if (hs.onStart !== null) {
            if (typeof hs.onStart !== "function") {
              hooksSpec = null;
              error = "invalid \"onStart\" hook: function expected";
              return { hooksSpec, error };
            }
            hooksSpec.onStart = hs.onStart;
          }
          if (hs.onError !== null) {
            if (typeof hs.onError !== "function") {
              hooksSpec = null;
              error = "invalid \"onError\" hook: function expected";
              return { hooksSpec, error };
            }
            hooksSpec.onError = hs.onError;
          }
          if (hs.onFinish !== null) {
            if (typeof hs.onFinish !== "function") {
              hooksSpec = null;
              error = "invalid \"onFinish\" hook: function expected";
              return { hooksSpec, error };
            }
            hooksSpec.onFinish = hs.onFinish;
          }
          return {hooksSpec, error}
        }
        function testMessages(ms) {

        }
        function testObjects(os, knownsType) {
          let objectsSpec = [],
              error = null;
          if (!Array.isArray(os)) {
            objectsSpec = null;
            error = "invalid objects: array expected";
            return {objectsSpec, error};
          }
          for (let i = 0,
                   o = os[i];
               i < os.length;
               o = os[i++]) {
            if (typeof o !== "object") {
              objectsSpec = null;
              error = `invalid Obj-object (#defID "${i}"): object expected`;
              return {objectsSpec, error}
            }
            let {t, ps} = o;
            if (typeof t !== "string") {
              objectsSpec = null;
              error = `invalid Obj-object (#defID "${i}") type: string expected`;
              return {objectsSpec, error}
            }
            let {type, ok} = knowsType(t);
            let objectSpec = {
              type: type,
              props: [],
            };
            if(!ok) {
              objectsSpec = null;
              error = `invalid Obj-object (#defID "${i}") type: unknown "${t}" type`;
              return { objectsSpec, error }
            }
            if (typeof ps !== "object") {
              objectsSpec = null;
              error = `invalid Obj-object (#defID "${i}") props: object expected`;
              return {objectsSpec, error}
            }
            let props = {};
            for (let p in ps) {
              if (ps.hasOwnProperty(p)) {
                let knows = false;
                for (let ii = 0,
                         pSpec = type.props[ii];
                     ii < type.props.length;
                     pSpec = type.props[ii++]) {
                  if (pSpec.name === p.name) {
                    knows = true;
                    break;
                  }
                }
                if (!knows) {
                  objectsSpec = null;
                  error = `invalid property: "${t.name}" type has no "${p.name}" property specified`
                  return { objectsSpec, error }
                }
                props[p] = ps[p]
              }
            }
            objectsSpec.push({type, props})
          }
          return {objectsSpec, error}
        }
        Obj.universe = (n, spec, vm) => {
          let name = n,
              types = {},
              channels = {},
              runtimeHooks = {},
              objects = [],
              messages = [];


          let channelsResult = testChannels(spec.channels);
          if (channelsResult.error !== null) {
            return channelsSpec.error;
          }
          let typesResult = testTypes(spec.types);
          if (typesResult.error !== null) {
            return typesResult.error;
          }
          let runtimeResult = testRuntime(spec.runtime)
          if (runtimeResult.error !== null) {
            return runtimeResult.error;
          }
          return () => {

          }
        }

        Obj.vm = (spec) => {

        }
    </script>

    <script>
      const univ =
      Obj.universe("univ", {
        types: [
          {
            name: "some",
            props: [
              {
                name: "a",
                guard: p => {  },
              },
              {
                name: "b",
                guard: p => {  },
              }
            ],
            invariant: props => {  },
            creator: ps => {  },
            destroyer: state => {  },
            reactions: [
              {
                event: "orderReceived",
                reactor: {
                  emits: "orderConfirmed",
                  handler: m => {  },
                },
              },
              {
                event: "orderConfirmed",
                reactor: {
                  emits: null,
                  handler: msg => {  },
                },
              },
              {
                event: "orderPackaged",
                reactor: {
                  emits: [],
                  handler: msg => {  },
                },
              }
            ]
          }
        ],
        channels: [
          {
            name:  "orderReceived",
            guard: msg => {  },
          },
          {
            name: "orderConfirmed",
            guard: msg => {  },
          }
        ],
        runtime: {
          hooks:{
            onStart: env => {  },
            onError: err => {  },
            onFinish: env => {  },
          },
          objects: [
            {
              type: "some",
              props: {  },
            },
            {
              type: "some",
              props: {  },
            }
          ],
          messages: [
            {
              chan: "orderReceived",
              message: {  },
            },
          ],
        },
      });
    </script>
    <script>
      const framework = (function(window){
        let framework = {
          version: "0.0.1",
          known: {
            nodeTypes: {

            },
            HTTPMethods: {

            },
            errors: {
              BAD_REQUEST: "bad request",
              SERVER_ERROR: "server error",
              RESPONSE_TIMEOUT: "response timeout",
            },
          },
        };
        framework.app = function (name, setupApp) {
          const proxy = new AppProxy()
          setupApp(proxy);
          if (proxy.error != null) {
            return
          }
          //return proxy.makeApp()
        };
        // app constructor
        function App(name, router, screens, widgets, onError, onInit) {
          this.name = name;
          this.router = router;
          this.screens = screens;
          this.widgets = widgets;
          this.onInit = onInit;
          this.onError = onError;
        }
        function AppProxy() {

        }
        AppProxy.prototype.onError = function(handler) {

        }
        AppProxy.prototype.onInit = function (handler) {

        }
        AppProxy.prototype.routing = function (setupRoutes) {
          if (this.error != null){
            return
          }
          const proxy = new RouterProxy();
          setupRoutes(proxy);
          if (proxy.error != null) {
            this.error = proxy.error
            return
          }
          this.router = proxy.makeRouter()
        }
        AppProxy.prototype.screen = function (name, setupScreen) {
          if (this.error != null) {
            return
          }
          if (this.screens.hasOwnProperty(name)){
            this.error = `screen "${name}" already specified`
            return
          }
          const sp = new ScreenProxy();
          setupScreen(sp);
          if (sp.error != null) {
            this.error = sp.error;
            return
          }
          const screen = sp.makeScreen();
          this.screens[name] = screen;
        }
        AppProxy.prototype.widget = function (name, setupWidget) {
          if (this.error !=null) {
            return
          }
          if(this.widgets.hasOwnProperty(name)) {
            this.error = `widget "${name} already specified"`
            return
          }
          const wp = new WidgetProxy();
          setupWidget(wp);
          if (wp.error != null) {
            this.error = wp.error
            return
          }
          return wp.makeWidget()
        };
        AppProxy.prototype.request = function(name, requestSetup) {

        }
        // request constructor
        function Request(title, params, fn) {
          this.title = title;
          this.params = params;
          this.fn = fn;
        }
        // requestProxy constructor
        function RequestProxy() {

        }
        RequestProxy.prototype.param = function(name, typ, isRequired) {

        }
        // screen constructor
        function Screen(title, widgets, onInit, onDisplay, onExit) {
          this.title = title;
          this.widgets = widgets;
          this.onInit = onInit;
          this.onDisplay = onDisplay;
          this.onExit = onExit;
        }
        // screenProxy constructor
        function ScreenProxy() {

        }
        ScreenProxy.prototype.widget = function(widget){

        }
        // router constructor
        function Router(root, onRouteNotFound, onRouteNotAllowed) {
          this.root = root;
          this.onRouteNotFound = onRouteNotFound;
          this.onRouteNotAllowed = onRouteNotAllowed;
        }
        // routerProxy constructor
        function RouterProxy() {

        }
        RouterProxy.prototype.onRouteNotFound = function() {

        }
        RouterProxy.prototype.onRouteNotAllowed = function() {

        }
        RouterProxy.prototype.root = function(setupNode){
          if (this.error != null) {
            return
          }
          if(this.root != null) {
            this.error = "root node already specified";
            return
          }
          const np = new NodeProxy();
          setupNode(np)
          if (np.error != null) {
            this.error = np.error
            return
          }
          this.root = np.makeNode();
        };
        // node constructor
        function Node(title, children, screenName){
          this.title = title;
          this.children = children;
          this.screenName = screenName;
        }
        // nodeProxy constructor
        function NodeProxy() {

        }
        NodeProxy.prototype.transition = function(name, params) {

        }
        NodeProxy.prototype.node = function(nodeHeader, setupNode) {

        }
        return framework;
      })(window)

      // usage
      const app = framework.app("myApp", function(app){
        app.onError();
        app.onInit();
      })
    </script>
  </head>
  <body>

  </body>
</html>
